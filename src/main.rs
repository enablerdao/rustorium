use std::process::{Command, Stdio};
use anyhow::Result;
use tracing::Level;
use tracing_subscriber::FmtSubscriber;
use std::env;
use std::time::Duration;
use dialoguer::{theme::ColorfulTheme, Select};
use console::{Term, style};
use indicatif::{ProgressBar, ProgressStyle};

// „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥„ÅÆÂÆöÁæ©
#[derive(Debug, Clone)]
struct BlockchainCommand {
    command_type: String,
    description: String,
    args: Vec<String>,
}

#[derive(Debug, Clone)]
struct LocaleConfig {
    language: String,
    commands: Vec<BlockchainCommand>,
    messages: std::collections::HashMap<String, String>,
}

#[derive(Debug, Clone)]
struct AppState {
    api_port: u16,
    frontend_port: u16,
    locale: LocaleConfig,
    api_url: String,
    frontend_url: String,
}

impl LocaleConfig {
    fn new(language: &str) -> Self {
        let messages = match language {
            "ja" => {
                let mut m = std::collections::HashMap::new();
                m.insert("welcome".to_string(), "Rustorium„Å∏„Çà„ÅÜ„Åì„ÅùÔºÅ".to_string());
                m.insert("select_action".to_string(), "ÂÆüË°å„Åó„Åü„ÅÑ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö".to_string());
                m.insert("account".to_string(), "„Ç¢„Ç´„Ç¶„É≥„ÉàÁÆ°ÁêÜ".to_string());
                m.insert("transaction".to_string(), "„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥".to_string());
                m.insert("smart_contract".to_string(), "„Çπ„Éû„Éº„Éà„Ç≥„É≥„Éà„É©„ÇØ„Éà".to_string());
                m.insert("blockchain".to_string(), "„Éñ„É≠„ÉÉ„ÇØ„ÉÅ„Çß„Éº„É≥ÊÉÖÂ†±".to_string());
                m.insert("settings".to_string(), "Ë®≠ÂÆö".to_string());
                m.insert("exit".to_string(), "ÁµÇ‰∫Ü".to_string());
                m
            },
            "en" => {
                let mut m = std::collections::HashMap::new();
                m.insert("welcome".to_string(), "Welcome to Rustorium!".to_string());
                m.insert("select_action".to_string(), "Select an action to perform:".to_string());
                m.insert("account".to_string(), "Account Management".to_string());
                m.insert("transaction".to_string(), "Transactions".to_string());
                m.insert("smart_contract".to_string(), "Smart Contracts".to_string());
                m.insert("blockchain".to_string(), "Blockchain Info".to_string());
                m.insert("settings".to_string(), "Settings".to_string());
                m.insert("exit".to_string(), "Exit".to_string());
                m
            },
            "zh" => {
                let mut m = std::collections::HashMap::new();
                m.insert("welcome".to_string(), "Ê¨¢Ëøé‰ΩøÁî® RustoriumÔºÅ".to_string());
                m.insert("select_action".to_string(), "ËØ∑ÈÄâÊã©Ë¶ÅÊâßË°åÁöÑÊìç‰ΩúÔºö".to_string());
                m.insert("account".to_string(), "Ë¥¶Êà∑ÁÆ°ÁêÜ".to_string());
                m.insert("transaction".to_string(), "‰∫§Êòì".to_string());
                m.insert("smart_contract".to_string(), "Êô∫ËÉΩÂêàÁ∫¶".to_string());
                m.insert("blockchain".to_string(), "Âå∫ÂùóÈìæ‰ø°ÊÅØ".to_string());
                m.insert("settings".to_string(), "ËÆæÁΩÆ".to_string());
                m.insert("exit".to_string(), "ÈÄÄÂá∫".to_string());
                m
            },
            "ko" => {
                let mut m = std::collections::HashMap::new();
                m.insert("welcome".to_string(), "RustoriumÏóê Ïò§Ïã† Í≤ÉÏùÑ ÌôòÏòÅÌï©ÎãàÎã§!".to_string());
                m.insert("select_action".to_string(), "Ïã§ÌñâÌï† ÏûëÏóÖÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:".to_string());
                m.insert("account".to_string(), "Í≥ÑÏ†ï Í¥ÄÎ¶¨".to_string());
                m.insert("transaction".to_string(), "Ìä∏ÎûúÏû≠ÏÖò".to_string());
                m.insert("smart_contract".to_string(), "Ïä§ÎßàÌä∏ Ïª®Ìä∏ÎûôÌä∏".to_string());
                m.insert("blockchain".to_string(), "Î∏îÎ°ùÏ≤¥Ïù∏ Ï†ïÎ≥¥".to_string());
                m.insert("settings".to_string(), "ÏÑ§Ï†ï".to_string());
                m.insert("exit".to_string(), "Ï¢ÖÎ£å".to_string());
                m
            },
            _ => std::collections::HashMap::new(),
        };

        Self {
            language: language.to_string(),
            commands: Vec::new(),
            messages,
        }
    }

    fn get_message<'a>(&'a self, key: &'a str) -> &'a str {
        self.messages.get(key).map(|s| s.as_str()).unwrap_or(key)
    }
}

#[derive(Debug, Clone)]
struct AppOptions {
    api_port: Option<u16>,
    frontend_port: Option<u16>,
    log_level: Option<String>,
    cors_origin: Option<String>,
}

impl AppOptions {
    fn new() -> Self {
        Self {
            api_port: None,
            frontend_port: None,
            log_level: None,
            cors_origin: None,
        }
    }

    fn parse_args() -> Self {
        let args: Vec<String> = env::args().collect();
        let mut options = Self::new();
        let mut i = 1;
        
        while i < args.len() {
            match args[i].as_str() {
                "--api-port" => {
                    i += 1;
                    if i < args.len() {
                        if let Ok(port) = args[i].parse() {
                            options.api_port = Some(port);
                        }
                    }
                }
                "--frontend-port" => {
                    i += 1;
                    if i < args.len() {
                        if let Ok(port) = args[i].parse() {
                            options.frontend_port = Some(port);
                        }
                    }
                }
                "--log-level" => {
                    i += 1;
                    if i < args.len() {
                        options.log_level = Some(args[i].clone());
                    }
                }
                "--cors-origin" => {
                    i += 1;
                    if i < args.len() {
                        options.cors_origin = Some(args[i].clone());
                    }
                }
                "-h" | "--help" => {
                    print_help();
                    std::process::exit(0);
                }
                "-v" | "--version" => {
                    println!("Rustorium v{}", env!("CARGO_PKG_VERSION"));
                    std::process::exit(0);
                }
                _ => {}
            }
            i += 1;
        }
        
        options
    }

    fn display_logo() {
        println!("{}", style(r#"
    ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
    ‚îÇ                                      ‚îÇ
    ‚îÇ   ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ  RUSTORIUM            ‚îÇ
    ‚îÇ   ‚îÇ ‚Çø ‚îÇ ‚ü† ‚îÇ ‚îÇ                       ‚îÇ
    ‚îÇ   ‚îÇ ‚óé ‚îÇ ‚Ç≥ ‚îÇ ‚îÇ  Blockchain Platform  ‚îÇ
    ‚îÇ   ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ                       ‚îÇ
    ‚îÇ                                      ‚îÇ
    ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
    "#).cyan());
    }

    async fn interactive_console(app_state: &AppState) -> Result<()> {
        let term = Term::stdout();
        term.clear_screen()?;
        
        Self::display_logo();

        // Ë®ÄË™ûÈÅ∏Êäû
        let languages = vec!["English", "Êó•Êú¨Ë™û", "‰∏≠Êñá", "ÌïúÍµ≠Ïñ¥"];
        let language_selection = Select::with_theme(&ColorfulTheme::default())
            .with_prompt(style("Select your language / Ë®ÄË™û„ÇíÈÅ∏Êäû / ÈÄâÊã©ËØ≠Ë®Ä / Ïñ∏Ïñ¥ ÏÑ†ÌÉù").cyan().bold().to_string())
            .items(&languages)
            .default(0)
            .interact()?;

        let language_code = match language_selection {
            0 => "en",
            1 => "ja",
            2 => "zh",
            3 => "ko",
            _ => "en",
        };

        let locale = LocaleConfig::new(language_code);
        println!("\n{}", style(locale.get_message("welcome")).bold());
        println!("\n{}", style("üåê Services:").cyan().bold());
        println!("  API: {}", style(&app_state.api_url).underlined());
        println!("  Frontend: {}", style(&app_state.frontend_url).underlined());
        println!();

        loop {
            let actions = vec![
                locale.get_message("account"),
                locale.get_message("transaction"),
                locale.get_message("smart_contract"),
                locale.get_message("blockchain"),
                locale.get_message("settings"),
                locale.get_message("exit"),
            ];

            let selection = Select::with_theme(&ColorfulTheme::default())
                .with_prompt(style(locale.get_message("select_action")).cyan().bold().to_string())
                .items(&actions)
                .default(0)
                .interact()?;

            match selection {
                0 => Self::handle_account_management(&locale).await?,
                1 => Self::handle_transactions(&locale).await?,
                2 => Self::handle_smart_contracts(&locale).await?,
                3 => Self::handle_blockchain_info(&locale).await?,
                4 => Self::handle_settings(&locale).await?,
                5 => break,
                _ => {}
            }

            println!();
        }

        Ok(())
    }

    async fn handle_account_management(_locale: &LocaleConfig) -> Result<()> {
        // „Ç¢„Ç´„Ç¶„É≥„ÉàÁÆ°ÁêÜ„ÅÆÂÆüË£Ö
        Ok(())
    }

    async fn handle_transactions(_locale: &LocaleConfig) -> Result<()> {
        // „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥ÁÆ°ÁêÜ„ÅÆÂÆüË£Ö
        Ok(())
    }

    async fn handle_smart_contracts(_locale: &LocaleConfig) -> Result<()> {
        // „Çπ„Éû„Éº„Éà„Ç≥„É≥„Éà„É©„ÇØ„ÉàÁÆ°ÁêÜ„ÅÆÂÆüË£Ö
        Ok(())
    }

    async fn handle_blockchain_info(_locale: &LocaleConfig) -> Result<()> {
        // „Éñ„É≠„ÉÉ„ÇØ„ÉÅ„Çß„Éº„É≥ÊÉÖÂ†±„ÅÆÂÆüË£Ö
        Ok(())
    }

    async fn handle_settings(_locale: &LocaleConfig) -> Result<()> {
        // Ë®≠ÂÆö„ÅÆÂÆüË£Ö
        Ok(())
    }
}

fn print_help() {
    println!("{}", style("Rustorium - Blockchain Platform").bold());
    println!();
    println!("{}", style("USAGE:").yellow());
    println!("  cargo run [OPTIONS]");
    println!();
    println!("{}", style("PORT OPTIONS:").yellow());
    println!("  --api-port <PORT>      API server port (default: auto)");
    println!("  --frontend-port <PORT> Frontend server port (default: auto)");
    println!();
    println!("{}", style("ADDITIONAL OPTIONS:").yellow());
    println!("  --log-level <LEVEL>    Set logging level (default: info)");
    println!("  --cors-origin <ORIGIN> Set CORS origin (default: *)");
    println!("  -h, --help            Show this help message");
    println!("  -v, --version         Show version information");
}

#[tokio::main]
async fn main() -> Result<()> {
    // „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥„ÅÆËß£Êûê
    let options = AppOptions::parse_args();
    
    // „É≠„ÇÆ„É≥„Ç∞„É¨„Éô„É´„ÅÆË®≠ÂÆö
    let log_level = match options.log_level.as_deref() {
        Some("debug") => Level::DEBUG,
        Some("warn") => Level::WARN,
        Some("error") => Level::ERROR,
        Some("trace") => Level::TRACE,
        _ => Level::INFO,
    };

    // „É≠„ÇÆ„É≥„Ç∞„ÅÆË®≠ÂÆö
    let subscriber = FmtSubscriber::builder()
        .with_max_level(log_level)
        .finish();

    // „Éù„Éº„ÉàË®≠ÂÆö
    let api_port = options.api_port.unwrap_or(53036);
    let frontend_port = options.frontend_port.unwrap_or(55938);

    // „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Áä∂ÊÖã„ÅÆÂàùÊúüÂåñ
    let app_state = AppState {
        api_port,
        frontend_port,
        locale: LocaleConfig::new("en"), // „Éá„Éï„Ç©„É´„Éà„ÅØËã±Ë™û
        api_url: format!("http://localhost:{}", api_port),
        frontend_url: format!("http://localhost:{}", frontend_port),
    };
    
    tracing::subscriber::set_global_default(subscriber)
        .expect("Failed to set tracing subscriber");

    // „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÅÆ„Çπ„Çø„Ç§„É´„ÇíË®≠ÂÆö
    let spinner_style = ProgressStyle::with_template("{spinner:.green} {msg}")
        .unwrap()
        .tick_chars("‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è");

    // „Çµ„Éº„Éì„Çπ„ÅÆËµ∑Âãï
    let spinner = ProgressBar::new_spinner();
    spinner.set_style(spinner_style.clone());
    spinner.set_message("Starting services...".to_string());
    spinner.enable_steady_tick(Duration::from_millis(100));

    // API„Çµ„Éº„Éê„Éº„ÅÆËµ∑Âãï
    let api_args = "cargo run".split_whitespace().collect::<Vec<&str>>();
    let _api_process = Command::new(api_args[0])
        .current_dir("api")
        .args(&api_args[1..])
        .args(["--bin", "api"])
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .spawn()?;

    // „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Çµ„Éº„Éê„Éº„ÅÆËµ∑Âãï
    let frontend_args = "cargo run".split_whitespace().collect::<Vec<&str>>();
    let _frontend_process = Command::new(frontend_args[0])
        .current_dir("frontend")
        .args(&frontend_args[1..])
        .args(["--bin", "frontend"])
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .spawn()?;

    // „Çµ„Éº„Éì„Çπ„ÅÆËµ∑Âãï„ÇíÂæÖÊ©ü
    tokio::time::sleep(tokio::time::Duration::from_secs(3)).await;
    spinner.finish_with_message("‚ú® All services started successfully!");
    println!();

    // „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Ç≥„É≥„ÇΩ„Éº„É´„ÅÆËµ∑Âãï
    AppOptions::interactive_console(&app_state).await?;

    // ÁµÇ‰∫ÜÂá¶ÁêÜ
    println!("\n{}", style("Shutting down services...").yellow());
    let _ = Command::new("pkill")
        .args(["-f", "target/debug/api"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status();

    let _ = Command::new("pkill")
        .args(["-f", "target/debug/frontend"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status();

    println!("{}", style("‚ú® Thank you for using Rustorium!").green().bold());
    Ok(())
}