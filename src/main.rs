use std::process::{Command, Stdio};
use anyhow::Result;
use tracing::Level;
use tracing_subscriber::FmtSubscriber;
use std::env;
use std::time::Duration;
use dialoguer::{theme::ColorfulTheme, Select};
use console::{Term, style};
use indicatif::{ProgressBar, ProgressStyle};
use structopt::StructOpt;

mod dev;
use dev::TestNodeManager;

// „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥„ÅÆÂÆöÁæ©
#[derive(Debug, Clone)]
struct BlockchainCommand {
    command_type: String,
    description: String,
    args: Vec<String>,
}

#[derive(Debug, Clone)]
struct LocaleConfig {
    language: String,
    commands: Vec<BlockchainCommand>,
    messages: std::collections::HashMap<String, String>,
}

#[derive(Debug, Clone)]
struct AppState {
    api_port: u16,
    frontend_port: u16,
    locale: LocaleConfig,
    api_url: String,
    frontend_url: String,
}

impl LocaleConfig {
    fn new(language: &str) -> Self {
        let messages = match language {
            "ja" => {
                let mut m = std::collections::HashMap::new();
                m.insert("welcome".to_string(), "Rustorium„Å∏„Çà„ÅÜ„Åì„ÅùÔºÅ".to_string());
                m.insert("select_action".to_string(), "ÂÆüË°å„Åó„Åü„ÅÑ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºö".to_string());
                m.insert("account".to_string(), "„Ç¢„Ç´„Ç¶„É≥„ÉàÁÆ°ÁêÜ".to_string());
                m.insert("transaction".to_string(), "„Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥".to_string());
                m.insert("smart_contract".to_string(), "„Çπ„Éû„Éº„Éà„Ç≥„É≥„Éà„É©„ÇØ„Éà".to_string());
                m.insert("blockchain".to_string(), "„Éñ„É≠„ÉÉ„ÇØ„ÉÅ„Çß„Éº„É≥ÊÉÖÂ†±".to_string());
                m.insert("settings".to_string(), "Ë®≠ÂÆö".to_string());
                m.insert("exit".to_string(), "ÁµÇ‰∫Ü".to_string());
                m
            },
            "en" => {
                let mut m = std::collections::HashMap::new();
                m.insert("welcome".to_string(), "Welcome to Rustorium!".to_string());
                m.insert("select_action".to_string(), "Select an action to perform:".to_string());
                m.insert("account".to_string(), "Account Management".to_string());
                m.insert("transaction".to_string(), "Transactions".to_string());
                m.insert("smart_contract".to_string(), "Smart Contracts".to_string());
                m.insert("blockchain".to_string(), "Blockchain Info".to_string());
                m.insert("settings".to_string(), "Settings".to_string());
                m.insert("exit".to_string(), "Exit".to_string());
                m
            },
            "zh" => {
                let mut m = std::collections::HashMap::new();
                m.insert("welcome".to_string(), "Ê¨¢Ëøé‰ΩøÁî® RustoriumÔºÅ".to_string());
                m.insert("select_action".to_string(), "ËØ∑ÈÄâÊã©Ë¶ÅÊâßË°åÁöÑÊìç‰ΩúÔºö".to_string());
                m.insert("account".to_string(), "Ë¥¶Êà∑ÁÆ°ÁêÜ".to_string());
                m.insert("transaction".to_string(), "‰∫§Êòì".to_string());
                m.insert("smart_contract".to_string(), "Êô∫ËÉΩÂêàÁ∫¶".to_string());
                m.insert("blockchain".to_string(), "Âå∫ÂùóÈìæ‰ø°ÊÅØ".to_string());
                m.insert("settings".to_string(), "ËÆæÁΩÆ".to_string());
                m.insert("exit".to_string(), "ÈÄÄÂá∫".to_string());
                m
            },
            "ko" => {
                let mut m = std::collections::HashMap::new();
                m.insert("welcome".to_string(), "RustoriumÏóê Ïò§Ïã† Í≤ÉÏùÑ ÌôòÏòÅÌï©ÎãàÎã§!".to_string());
                m.insert("select_action".to_string(), "Ïã§ÌñâÌï† ÏûëÏóÖÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:".to_string());
                m.insert("account".to_string(), "Í≥ÑÏ†ï Í¥ÄÎ¶¨".to_string());
                m.insert("transaction".to_string(), "Ìä∏ÎûúÏû≠ÏÖò".to_string());
                m.insert("smart_contract".to_string(), "Ïä§ÎßàÌä∏ Ïª®Ìä∏ÎûôÌä∏".to_string());
                m.insert("blockchain".to_string(), "Î∏îÎ°ùÏ≤¥Ïù∏ Ï†ïÎ≥¥".to_string());
                m.insert("settings".to_string(), "ÏÑ§Ï†ï".to_string());
                m.insert("exit".to_string(), "Ï¢ÖÎ£å".to_string());
                m
            },
            _ => std::collections::HashMap::new(),
        };

        Self {
            language: language.to_string(),
            commands: Vec::new(),
            messages,
        }
    }

    fn get_message<'a>(&'a self, key: &'a str) -> &'a str {
        self.messages.get(key).map(|s| s.as_str()).unwrap_or(key)
    }
}

#[derive(StructOpt, Debug)]
#[structopt(name = "rustorium")]
struct AppOptions {
    /// API server port
    #[structopt(long, env = "API_PORT")]
    api_port: Option<u16>,

    /// Frontend server port
    #[structopt(long, env = "FRONTEND_PORT")]
    frontend_port: Option<u16>,

    /// Log level (debug, info, warn, error)
    #[structopt(long, env = "LOG_LEVEL")]
    log_level: Option<String>,

    /// CORS origin
    #[structopt(long, env = "CORS_ORIGIN")]
    cors_origin: Option<String>,

    /// Development mode: Start multiple test nodes
    #[structopt(long)]
    dev: bool,

    /// Number of test nodes to start (in dev mode)
    #[structopt(long, default_value = "10")]
    nodes: u8,

    /// Base port for test nodes (in dev mode)
    #[structopt(long, default_value = "40000")]
    base_port: u16,

    /// Data directory for test nodes (in dev mode)
    #[structopt(long, default_value = "/tmp/rustorium_test")]
    data_dir: String,
}

impl AppOptions {
    fn new() -> Self {
        Self::from_args()
    }

    fn display_logo() {
        println!("{}", style(r#"
    ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
    ‚îÇ                                      ‚îÇ
    ‚îÇ   ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ  RUSTORIUM            ‚îÇ
    ‚îÇ   ‚îÇ ‚Çø ‚îÇ ‚ü† ‚îÇ ‚îÇ                       ‚îÇ
    ‚îÇ   ‚îÇ ‚óé ‚îÇ ‚Ç≥ ‚îÇ ‚îÇ  Blockchain Platform  ‚îÇ
    ‚îÇ   ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ                       ‚îÇ
    ‚îÇ                                      ‚îÇ
    ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
    "#).cyan());
    }

    async fn interactive_console(app_state: &AppState) -> Result<()> {
        let term = Term::stdout();
        term.clear_screen()?;
        
        Self::display_logo();

        // Ë®ÄË™ûÈÅ∏Êäû
        let languages = vec!["English", "Êó•Êú¨Ë™û", "‰∏≠Êñá", "ÌïúÍµ≠Ïñ¥"];
        let language_selection = Select::with_theme(&ColorfulTheme::default())
            .with_prompt(style("Select your language / Ë®ÄË™û„ÇíÈÅ∏Êäû / ÈÄâÊã©ËØ≠Ë®Ä / Ïñ∏Ïñ¥ ÏÑ†ÌÉù").cyan().bold().to_string())
            .items(&languages)
            .default(0)
            .interact()?;

        let language_code = match language_selection {
            0 => "en",
            1 => "ja",
            2 => "zh",
            3 => "ko",
            _ => "en",
        };

        let locale = LocaleConfig::new(language_code);
        println!("\n{}", style(locale.get_message("welcome")).bold());
        println!("\n{}", style("üåê Services:").cyan().bold());
        println!("  API: {}", style(&app_state.api_url).underlined());
        println!("  Frontend: {}", style(&app_state.frontend_url).underlined());
        println!();

        loop {
            let actions = vec![
                locale.get_message("account"),
                locale.get_message("transaction"),
                locale.get_message("smart_contract"),
                locale.get_message("blockchain"),
                locale.get_message("settings"),
                locale.get_message("exit"),
            ];

            let selection = Select::with_theme(&ColorfulTheme::default())
                .with_prompt(style(locale.get_message("select_action")).cyan().bold().to_string())
                .items(&actions)
                .default(0)
                .interact()?;

            match selection {
                0 => Self::handle_account_management(&locale).await?,
                1 => Self::handle_transactions(&locale).await?,
                2 => Self::handle_smart_contracts(&locale).await?,
                3 => Self::handle_blockchain_info(&locale).await?,
                4 => Self::handle_settings(&locale).await?,
                5 => break,
                _ => {}
            }

            println!();
        }

        Ok(())
    }

    async fn handle_account_management(_locale: &LocaleConfig) -> Result<()> {
        // „Ç¢„Ç´„Ç¶„É≥„ÉàÁÆ°ÁêÜ„ÅÆÂÆüË£Ö
        Ok(())
    }

    async fn handle_transactions(_locale: &LocaleConfig) -> Result<()> {
        // „Éà„É©„É≥„Ç∂„ÇØ„Ç∑„Éß„É≥ÁÆ°ÁêÜ„ÅÆÂÆüË£Ö
        Ok(())
    }

    async fn handle_smart_contracts(_locale: &LocaleConfig) -> Result<()> {
        // „Çπ„Éû„Éº„Éà„Ç≥„É≥„Éà„É©„ÇØ„ÉàÁÆ°ÁêÜ„ÅÆÂÆüË£Ö
        Ok(())
    }

    async fn handle_blockchain_info(_locale: &LocaleConfig) -> Result<()> {
        // „Éñ„É≠„ÉÉ„ÇØ„ÉÅ„Çß„Éº„É≥ÊÉÖÂ†±„ÅÆÂÆüË£Ö
        Ok(())
    }

    async fn handle_settings(_locale: &LocaleConfig) -> Result<()> {
        // Ë®≠ÂÆö„ÅÆÂÆüË£Ö
        Ok(())
    }
}

fn print_help() {
    println!("{}", style("Rustorium - Blockchain Platform").bold());
    println!();
    println!("{}", style("USAGE:").yellow());
    println!("  cargo run [OPTIONS]");
    println!();
    println!("{}", style("PORT OPTIONS:").yellow());
    println!("  --api-port <PORT>      API server port (default: auto)");
    println!("  --frontend-port <PORT> Frontend server port (default: auto)");
    println!();
    println!("{}", style("ADDITIONAL OPTIONS:").yellow());
    println!("  --log-level <LEVEL>    Set logging level (default: info)");
    println!("  --cors-origin <ORIGIN> Set CORS origin (default: *)");
    println!("  -h, --help            Show this help message");
    println!("  -v, --version         Show version information");
}

#[tokio::main]
async fn main() -> Result<()> {
    // „Ç≥„Éû„É≥„Éâ„É©„Ç§„É≥„Ç™„Éó„Ç∑„Éß„É≥„ÅÆËß£Êûê
    let options = AppOptions::new();
    
    // „É≠„ÇÆ„É≥„Ç∞„É¨„Éô„É´„ÅÆË®≠ÂÆö
    let log_level = match options.log_level.as_deref() {
        Some("debug") => Level::DEBUG,
        Some("warn") => Level::WARN,
        Some("error") => Level::ERROR,
        Some("trace") => Level::TRACE,
        _ => Level::INFO,
    };

    // „É≠„ÇÆ„É≥„Ç∞„ÅÆË®≠ÂÆö
    let subscriber = FmtSubscriber::builder()
        .with_max_level(log_level)
        .finish();

    tracing::subscriber::set_global_default(subscriber)
        .expect("Failed to set tracing subscriber");

    // ÈñãÁô∫„É¢„Éº„Éâ„ÅÆÂ†¥Âêà„ÅØ„ÉÜ„Çπ„Éà„Éé„Éº„Éâ„ÇíËµ∑Âãï
    if options.dev {
        println!("{}", style("\nüß™ Development Mode: Starting Test Nodes").yellow().bold());
        println!("{}", style("‚ö†Ô∏è  This mode is for development and testing only!").red());
        println!();

        let mut node_manager = TestNodeManager::new(options.base_port, options.data_dir.into());
        
        // „ÉÜ„Çπ„Éà„Éé„Éº„Éâ„ÇíËøΩÂä†
        for i in 1..=options.nodes {
            node_manager.add_node(i)?;
        }

        // „ÉÜ„Çπ„Éà„Éé„Éº„Éâ„ÇíËµ∑Âãï
        node_manager.start_nodes(options.nodes).await?;

        // Ctrl+C„ÇíÂæÖÊ©ü
        let (tx, rx) = tokio::sync::oneshot::channel();
        ctrlc::set_handler(move || {
            let _ = tx.send(());
        })?;

        println!("\n{}", style("Press Ctrl+C to stop all nodes").cyan());
        let _ = rx.await;
        
        println!("\n{}", style("Stopping all test nodes...").yellow());
        node_manager.stop_nodes().await?;
        println!("{}", style("‚ú® All test nodes stopped successfully!").green());
        return Ok(());
    }

    // ÈÄöÂ∏∏„É¢„Éº„Éâ: „Éù„Éº„ÉàË®≠ÂÆö
    let api_port = options.api_port.unwrap_or(53036);
    let frontend_port = options.frontend_port.unwrap_or(55938);

    // „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Áä∂ÊÖã„ÅÆÂàùÊúüÂåñ
    let app_state = AppState {
        api_port,
        frontend_port,
        locale: LocaleConfig::new("en"), // „Éá„Éï„Ç©„É´„Éà„ÅØËã±Ë™û
        api_url: format!("http://localhost:{}", api_port),
        frontend_url: format!("http://localhost:{}", frontend_port),
    };

    // „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÅÆ„Çπ„Çø„Ç§„É´„ÇíË®≠ÂÆö
    let spinner_style = ProgressStyle::with_template("{spinner:.green} {msg}")
        .unwrap()
        .tick_chars("‚†ã‚†ô‚†π‚†∏‚†º‚†¥‚†¶‚†ß‚†á‚†è");

    // „Çµ„Éº„Éì„Çπ„ÅÆËµ∑Âãï
    let spinner = ProgressBar::new_spinner();
    spinner.set_style(spinner_style.clone());
    spinner.set_message("Starting services...".to_string());
    spinner.enable_steady_tick(Duration::from_millis(100));

    // API„Çµ„Éº„Éê„Éº„ÅÆËµ∑Âãï
    let api_args = "cargo run".split_whitespace().collect::<Vec<&str>>();
    let _api_process = Command::new(api_args[0])
        .current_dir("api")
        .args(&api_args[1..])
        .args(["--bin", "api"])
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .spawn()?;

    // „Éï„É≠„É≥„Éà„Ç®„É≥„Éâ„Çµ„Éº„Éê„Éº„ÅÆËµ∑Âãï
    let frontend_args = "cargo run".split_whitespace().collect::<Vec<&str>>();
    let _frontend_process = Command::new(frontend_args[0])
        .current_dir("frontend")
        .args(&frontend_args[1..])
        .args(["--bin", "frontend"])
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .spawn()?;

    // „Çµ„Éº„Éì„Çπ„ÅÆËµ∑Âãï„ÇíÂæÖÊ©ü
    tokio::time::sleep(tokio::time::Duration::from_secs(3)).await;
    spinner.finish_with_message("‚ú® All services started successfully!");
    println!();

    // „Ç§„É≥„Çø„É©„ÇØ„ÉÜ„Ç£„Éñ„Ç≥„É≥„ÇΩ„Éº„É´„ÅÆËµ∑Âãï
    AppOptions::interactive_console(&app_state).await?;

    // ÁµÇ‰∫ÜÂá¶ÁêÜ
    println!("\n{}", style("Shutting down services...").yellow());
    let _ = Command::new("pkill")
        .args(["-f", "target/debug/api"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status();

    let _ = Command::new("pkill")
        .args(["-f", "target/debug/frontend"])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status();

    println!("{}", style("‚ú® Thank you for using Rustorium!").green().bold());
    Ok(())
}